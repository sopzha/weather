# weather
Created for 6.08: Embedded Systems at MIT.

# Video

Demo: <a href="https://youtu.be/4xCq4_tPoe8" target="_blank">https://youtu.be/4xCq4_tPoe8</a>

# Specifications

Below is how I addressed each specification:

## User Selection

**Requirement:**

* Develop a system that will display weather characteristics based on what the user requests on their ESP32 system. The system should use a button-based state machine (limit of two buttons). 
* Starting from a blank LCD, the system should prompt the user for one of six options:
    * Current local temperature
    * Current local time
    * Current date
    * Current local visibility (or weather)
    * Current local humidity
    * Current local pressure

**Implementation:**

At any given time, the screen display is dependent on the state of the system, denoted `draw_state` in code. When `draw_state` equals 0, the screen displays the menu of weather options where the user can make selections.
The user can toggle through the menu by clicking `BUTTON_TOGGLE`. At every click, the variable `temp_draw_state` is updated for the purpose of updating the position of the circular toggle marker. When the user makes a selection by clicking `BUTTON`, 
the `draw_state` is updated with the `temp_draw_state` value, and the screen switches to an updated series of statements. The variable `draw_state` is then reset to 0, returning to the main menu after every selection.

## Server Data Retrieval

**Requirement:**

* Following the selection, using a combination of server-based information and either direct or proxy-server based requests sent to the Open Weather API (which you'll need to sign up for a free account with), your device will perform a GET request to retrieve the appropriate information.

**Implementation:**

To make an HTTP GET request, I create a client object and connect to the host. I formulate the GET request into a char array, which is sent to the host of interest. The host parses the request and generates a response, which is placed in the response buffer char array.

To retrieve the date and time, I connect to the host iesc-s3.mit.edu, and I parse the response buffer char array generated by the host using the `strtok` function.
To retrieve all other weather-related information, I connect to the host api.openweathermap.org, and I deserialize the response buffer as a JSON object, a straightforward representation to access values.

## Building-list Display

**Requirement:**

* The device should display information in a building-list like way. New requests are displayed at the top, pushing old requests downwards. 
* When the list of data gets too long you should throw away old responses.

**Implementation:**

I intentionally restrict the number of statements printed on the screen to four. Each statement is stored in a char array variable. Whenever `draw_state` is updated to a non-zero value, I format a string including the selected option retrieved from the server and pass it into the function
`print_out`, which serves to add the string argument into the appropriate char array variable and format print statements on the screen. The function prints content from each of the four char arrays in an ordered manner, such that the newest response is always at the top of the screen. If all char array variables are filled, I empty the string located at the bottom of the screen and shift
each of the remaining strings down before updating the uppermost char array with the new statement.
